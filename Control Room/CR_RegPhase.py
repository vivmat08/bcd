from secrets import randbelow
import time
import socket
import pickle
from struct import *
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import ec

''' 
Generate a symmetric t-degree bivariate polynomial over the finite field GF(q) 
with coefficients in the range [0, q-1]. The polynomial is represented as a matrix
of size [t+1]*[t+1] where the (i,j)-th entry is the coefficient of x^i*y^j. Since
the matrix is symmetric, aij = aji for 0 <= i, j <= t+1.
'''
def generate_t_degree_poly(t: int, q: int) -> list(list()):
    polynomial = [[0 for _ in range(t + 1)] for _ in range(t + 1)]
    for i in range(t + 1):
        for j in range(t + 1):
            if j >= i:
                polynomial[i][j] = randbelow(q)
            else:
                polynomial[i][j] = polynomial[j][i]

    return polynomial


'''
Generates the polynomial share of the GSS using the pseudo identity of the GSS and 
the symmetric t-degree bivariate polynomial over GF(q) generated by the control room.
The result is a t degree polynomial in y with coefficients in GF(q), stored in a list,
with the ith element as the coefficient of the y^i.
'''
def generate_polynomial_share(polynomial: list(list()), x: int, q: int) -> list():

    # Precalculate powers of x modulo q till power t to avoid repeated computation
    # where t is the degree of the polynomial
    powers_of_x_modulo_q = [1] * len(polynomial)
    for i in range(1, len(polynomial)):
        powers_of_x_modulo_q[i] = (powers_of_x_modulo_q[i - 1] * x) % q

    polynomial_share = [0] * len(polynomial)
    for i in range(len(polynomial)):
        for j in range(len(polynomial)):
            polynomial_share[i] += polynomial[i][j] * powers_of_x_modulo_q[j]
            polynomial_share[i] %= q
    
    return polynomial_share



'''
Generate the pseudo identity of the GSS using the unique identity of GSS: ID_GSS
generated by the control room.
PID = h(ID_GSS||Private_key_CR||RegTimeStamp), where h is the SHA256 hash function
'''
def generate_PID(q: int, ID_entity: int) -> bytes:
    # Load private key of CR
    with open('CR_private.pem', 'rb') as f:
        private_key = serialization.load_pem_private_key(
            f.read(),
            password=None,
            backend=default_backend()
        )

    ID_entity_bytes = bytes(str(ID_entity), 'utf-8')    

    private_number = private_key.private_numbers().private_value
    private_number_bytes = bytes(str(private_number), 'utf-8')

    timestamp = time.time()
    timestamp_bytes = bytes(str(timestamp), 'utf-8')

    # Generate pseudo identity of entity
    hash = hashes.Hash(hashes.SHA256())
    hash.update(ID_entity_bytes)
    hash.update(private_number_bytes)
    hash.update(timestamp_bytes)
    pseudo_ID_entity = hash.finalize()

    return pseudo_ID_entity



'''
Generates a certificate using the pseudo identity of the entity 
and various other parameters.
'''
def generate_certificate(private_secret: int, PID: int, ID_CR: int, public_secret: int, public_key_text: str, private_key: int, q: int) -> int:
    cert_gss = 0

    hash = hashes.Hash(hashes.SHA256())
    hash.update(bytes(str(PID), 'utf-8'))
    hash.update(bytes(str(ID_CR), 'utf-8'))
    hash.update(bytes(str(public_secret), 'utf-8'))
    hash.update(bytes(public_key_text, 'utf-8'))

    cert_gss = private_secret + (int.from_bytes(hash.finalize(), byteorder='big') * private_key) % q
    cert_gss %= q

    return cert_gss

'''
Utility function to send byte stream data with length to the socket. 
Sends the length first by packing it into a 4 byte integer.
'''
def send_data_with_length(data: bytes, socket: socket.socket):
    length = len(data)
    socket.sendall(pack('>I', length))
    socket.sendall(data)


def register_GSS(t: int, q: int, polynomial: list(list())):

    # Read unique ID of GSS from the common ID file
    with open('ID.txt', 'r') as f:
        f.readline()
        ID_GSS = int(f.readline().split('\t')[1])

    # Generate pseudo identity of GSS
    pseudo_ID_GSS = generate_PID(q, ID_GSS)
    int_value_of_PID = int.from_bytes(pseudo_ID_GSS, byteorder='big')


    # Generate polynomial share of GSS
    polynomial_share = generate_polynomial_share(polynomial, int_value_of_PID, q)


    # Generate the public key of the GSS
    r_GSS = randbelow(q)
    GSS_private_secret = ec.derive_private_key(r_GSS, ec.SECP256K1())
    GSS_public_secret = GSS_private_secret.public_key()
    serialized_public_secret = GSS_public_secret.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
    )


    # Read unique ID of CR from the common ID file
    with open('ID.txt', 'r') as f:
        ID_CR = f.readline().split('\t')[1]


    # Load private key of CR
    with open('CR_private.pem', 'rb') as f:
        private_key = serialization.load_pem_private_key(
            f.read(),
            password=None,
            backend=default_backend()
        )
    private_value = private_key.private_numbers().private_value


    # Loading public key of CR as text
    with open('../Public/CR_public.pem', 'r') as f:
        public_key_text = f.read()


    # Generate certificate of GSS
    cert_GSS = generate_certificate(
        r_GSS, 
        pseudo_ID_GSS, 
        ID_CR, 
        GSS_public_secret, 
        public_key_text, 
        private_value,
        q
    )
    

    # Send the PID_GSS, polynomial share, certificate, and ID_CR to the GSS using sockets
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('localhost', 5050))
        s.listen(1)
        conn, addr = s.accept()


        send_data_with_length(pseudo_ID_GSS, conn)

        poly_dump = pickle.dumps(polynomial_share)
        send_data_with_length(poly_dump, conn)

        send_data_with_length(str(cert_GSS).encode(), conn)

        send_data_with_length(ID_CR.encode(), conn)

    with open('../Public/GSS_public_secret.pem', 'wb') as f:
        f.write(serialized_public_secret)

    print(int_value_of_PID)
    print(pickle.dumps(polynomial_share))
    print(cert_GSS)
    print(ID_CR)



def register_drones(t: int, q: int, polynomial: list(list())):

    # Read unique ID of CR from the common ID file
    with open('ID.txt', 'r') as f:
        # Skipping the first two lines containing the ID of the CR and GSS
        for _ in range(t + 2):
            f.readline()

        ID_drone = f.readline().split('\t')[1]
        
    # Generate pseudo identity of drones
    pseudo_ID_drones = generate_PID(q, ID_drone)
    int_value_of_PID = int.from_bytes(pseudo_ID_drones, byteorder='big')

    # Generate Temporary ID of drones
    temp_ID_drones = randbelow(q)

    with open('TID.txt', 'a') as f:
        f.write(str(temp_ID_drones) + '\n')

    # Generate polynomial share of drones
    polynomial_share = generate_polynomial_share(polynomial, int_value_of_PID, q)

    # Generate the public key of the drones
    r_drones = randbelow(q)
    drones_private_secret = ec.derive_private_key(r_drones, ec.SECP256K1())
    drones_public_secret = drones_private_secret.public_key()
    serialized_public_secret = drones_public_secret.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    # Read unique ID of CR from the common ID file
    with open('ID.txt', 'r') as f:
        ID_CR = f.readline().split('\t')[1]

    # Load private key of CR
    with open('CR_private.pem', 'rb') as f:
        private_key = serialization.load_pem_private_key(
            f.read(),
            password=None,
            backend=default_backend()
        )
    private_value = private_key.private_numbers().private_value

    # Loading public key of CR as text
    with open('../Public/CR_public.pem', 'r') as f:
        public_key_text = f.read()

    # Generate certificate of drones
    cert_drones = generate_certificate(
        r_drones, 
        pseudo_ID_drones, 
        ID_CR, 
        drones_public_secret, 
        public_key_text, 
        private_value,
        q
    )

    # Generate the private and public key of the drones
    private_key = ec.generate_private_key(ec.SECP256K1())
    private_value = private_key.private_numbers().private_value
    public_key = private_key.public_key()
    serialized_public_secret = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
    )

    # Send the PID_drones, polynomial share, certificate, and ID_CR to the drones using sockets
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('localhost', 5050))
        s.listen(1)
        conn, addr = s.accept()

        # Sending the temporary ID of the drone to the drone
        send_data_with_length(str(temp_ID_drones).encode(), conn)

        # Sending the pseudo ID of the drone to the drone
        send_data_with_length(pseudo_ID_drones, conn)

        # Sending the polynomial share to the drone
        poly_dump = pickle.dumps(polynomial_share)
        send_data_with_length(poly_dump, conn)

        # Sending the certificate of the drone to the drone
        send_data_with_length(str(cert_drones).encode(), conn)

        # Sending the ID of the CR to the drone
        send_data_with_length(ID_CR.encode(), conn)

        # Sending private key to drone
        send_data_with_length(str(private_value).encode(), conn)

        # Sending public key to drone
        send_data_with_length(serialized_public_secret, conn)

    with open(f'drone{t + 1}_public_secret.pem', 'wb') as f:
        f.write(serialized_public_secret)


def main():
    max_num_of_drones = 5

    # Finite field GF(q)
    q = (1 << 256) - (1 << 32) - 977

    # Generate unique ID of CR, GSS, and the drones and write it to the common ID file
    with open('ID.txt', 'w') as f:

        f.write(f"CR\t{str(randbelow(q))}")
        f.write(f"\nGSS\t{str(randbelow(q))}")

        for i in range(max_num_of_drones):
            f.write(f"\nDrone{i}\t{str(randbelow(q))}")

    # Degree of polynomial, much higher than the number of drones
    t = max_num_of_drones ** 2

    # Generate a symmetric t-degree bivariate polynomial over GF(q)
    polynomial = generate_t_degree_poly(t, q)

    # Register the GSS
    register_GSS(t, q, polynomial)
    
    # for i in range(max_num_of_drones):
    #     # Register the drones
    #     register_drones(i, q, polynomial)

if __name__ == "__main__":
    main()